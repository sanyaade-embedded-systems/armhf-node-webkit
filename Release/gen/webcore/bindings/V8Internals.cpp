/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include "config.h"
#include "V8Internals.h"

#include "BindingState.h"
#include "ContextFeatures.h"
#include "DOMStringList.h"
#include "ExceptionCode.h"
#include "Frame.h"
#include "RuntimeEnabledFeatures.h"
#include "SerializedScriptValue.h"
#include "V8ArrayBuffer.h"
#include "V8Binding.h"
#include "V8ClientRect.h"
#include "V8ClientRectList.h"
#include "V8DOMStringList.h"
#include "V8DOMWindow.h"
#include "V8DOMWrapper.h"
#include "V8Document.h"
#include "V8Element.h"
#include "V8InternalSettings.h"
#include "V8MallocStatistics.h"
#include "V8Node.h"
#include "V8NodeList.h"
#include "V8PagePopupController.h"
#include "V8Range.h"
#include "V8ShadowRoot.h"
#include "V8TypeConversions.h"
#include "V8WebKitPoint.h"
#include <wtf/ArrayBuffer.h>
#include <wtf/GetPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>
#include <wtf/UnusedParam.h>

namespace WebCore {

WrapperTypeInfo V8Internals::info = { V8Internals::GetTemplate, V8Internals::derefObject, 0, 0, V8Internals::installPerContextPrototypeProperties, 0, WrapperTypeObjectPrototype };

namespace InternalsV8Internal {

template <typename T> void V8_USE(T) { }

static v8::Handle<v8::Value> pagePopupControllerAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    Internals* imp = V8Internals::toNative(info.Holder());
    RefPtr<PagePopupController> result = imp->pagePopupController();
    v8::Handle<v8::Value> wrapper = result.get() ? v8::Handle<v8::Value>(DOMDataStore::getWrapper(result.get(), info.GetIsolate())) : v8Undefined();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get(), info.Holder(), info.GetIsolate());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "pagePopupController", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> settingsAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    Internals* imp = V8Internals::toNative(info.Holder());
    RefPtr<InternalSettings> result = imp->settings();
    v8::Handle<v8::Value> wrapper = result.get() ? v8::Handle<v8::Value>(DOMDataStore::getWrapper(result.get(), info.GetIsolate())) : v8Undefined();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get(), info.Holder(), info.GetIsolate());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "settings", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> addressCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return v8String(imp->address(node), args.GetIsolate());
}

static v8::Handle<v8::Value> elementRenderTreeAsTextCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->elementRenderTreeAsText(element, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> isPreloadedCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, url, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    return v8Boolean(imp->isPreloaded(document, url), args.GetIsolate());
}

static v8::Handle<v8::Value> numberOfScopedHTMLStyleChildrenCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, scope, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    unsigned result = imp->numberOfScopedHTMLStyleChildren(scope, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> ensureShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->ensureShadowRoot(host, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> createShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->createShadowRoot(host, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> shadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->shadowRoot(host, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> youngestShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->youngestShadowRoot(host, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> oldestShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->oldestShadowRoot(host, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> youngerShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->youngerShadowRoot(root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> olderShadowRootCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ShadowRoot> result = imp->olderShadowRoot(root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> shadowRootTypeCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->shadowRootType(root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasShadowInsertionPointCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    bool result = imp->hasShadowInsertionPoint(root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasContentElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    bool result = imp->hasContentElement(root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> countElementShadowCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, Root, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    unsigned result = imp->countElementShadow(Root, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> includerForCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Element> result = imp->includerFor(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> shadowPseudoIdCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->shadowPseudoId(element, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setShadowPseudoIdCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, id, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->setShadowPseudoId(element, id, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> createContentElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Element> result = imp->createContentElement(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> isValidContentSelectCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, contentElement, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    bool result = imp->isValidContentSelect(contentElement, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> treeScopeRootNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->treeScopeRootNode(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> parentTreeScopeCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->parentTreeScope(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasSelectorForIdInShadowCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, id, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    bool result = imp->hasSelectorForIdInShadow(host, id, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasSelectorForClassInShadowCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, className, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    bool result = imp->hasSelectorForClassInShadow(host, className, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasSelectorForAttributeInShadowCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, attributeName, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    bool result = imp->hasSelectorForAttributeInShadow(host, attributeName, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasSelectorForPseudoClassInShadowCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, host, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, pseudoClass, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    bool result = imp->hasSelectorForPseudoClassInShadow(host, pseudoClass, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> pauseAnimationAtTimeOnPseudoElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 4)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, animationName, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    V8TRYCATCH(double, pauseTime, static_cast<double>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, pseudoId, MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined));
    bool result = imp->pauseAnimationAtTimeOnPseudoElement(animationName, pauseTime, element, pseudoId, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> pauseTransitionAtTimeOnPseudoElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 4)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, property, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    V8TRYCATCH(double, pauseTime, static_cast<double>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, pseudoId, MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined));
    bool result = imp->pauseTransitionAtTimeOnPseudoElement(property, pauseTime, element, pseudoId, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> nextSiblingByWalkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->nextSiblingByWalker(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> firstChildByWalkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->firstChildByWalker(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> lastChildByWalkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->lastChildByWalker(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> nextNodeByWalkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->nextNodeByWalker(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> previousNodeByWalkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->previousNodeByWalker(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> attachedCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    bool result = imp->attached(node, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> visiblePlaceholderCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return v8String(imp->visiblePlaceholder(element), args.GetIsolate());
}

static v8::Handle<v8::Value> selectColorInColorChooserCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, colorValue, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->selectColorInColorChooser(element, colorValue);
    return v8Undefined();
}

static v8::Handle<v8::Value> formControlStateOfPreviousHistoryItemCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    RefPtr<DOMStringList> result = imp->formControlStateOfPreviousHistoryItem(ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Array(result.release(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setFormControlStateOfPreviousHistoryItemCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(RefPtr<DOMStringList>, values, toDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined), args.GetIsolate()));
    imp->setFormControlStateOfPreviousHistoryItem(values, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setEnableMockPagePopupCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(bool, enabled, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->BooleanValue());
    imp->setEnableMockPagePopup(enabled, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> absoluteCaretBoundsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ClientRect> result = imp->absoluteCaretBounds(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> boundingBoxCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ClientRect> result = imp->boundingBox(element, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> inspectorHighlightRectsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ClientRectList> result = imp->inspectorHighlightRects(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setBackgroundBlurOnNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, blurLength, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    imp->setBackgroundBlurOnNode(node, blurLength, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> markerCountForNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, markerType, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    unsigned result = imp->markerCountForNode(node, markerType, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> markerRangeForNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, markerType, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    V8TRYCATCH(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    RefPtr<Range> result = imp->markerRangeForNode(node, markerType, index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> markerDescriptionForNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Node*, node, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, markerType, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    V8TRYCATCH(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    String result = imp->markerDescriptionForNode(node, markerType, index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> addTextMatchMarkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Range*, range, V8Range::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Range::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(bool, isActive, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->BooleanValue());
    imp->addTextMatchMarker(range, isActive);
    return v8Undefined();
}

static v8::Handle<v8::Value> setScrollViewPositionCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    imp->setScrollViewPosition(document, x, y, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setPaginationCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, mode, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    V8TRYCATCH(int, gap, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    if (args.Length() <= 3) {
        imp->setPagination(document, mode, gap, ec);
        if (UNLIKELY(ec))
            goto fail;
        return v8Undefined();
    }
    V8TRYCATCH(int, pageLength, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    imp->setPagination(document, mode, gap, pageLength, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> configurationForViewportCallback(const v8::Arguments& args)
{
    if (args.Length() < 6)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(float, devicePixelRatio, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
    V8TRYCATCH(int, deviceWidth, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, deviceHeight, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(int, availableWidth, toInt32(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)));
    V8TRYCATCH(int, availableHeight, toInt32(MAYBE_MISSING_PARAMETER(args, 5, DefaultIsUndefined)));
    String result = imp->configurationForViewport(document, devicePixelRatio, deviceWidth, deviceHeight, availableWidth, availableHeight, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> wasLastChangeUserEditCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, textField, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    bool result = imp->wasLastChangeUserEdit(textField, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> suggestedValueCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, inputElement, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->suggestedValue(inputElement, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setSuggestedValueCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, inputElement, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, value, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->setSuggestedValue(inputElement, value, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setEditingValueCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, inputElement, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, value, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->setEditingValue(inputElement, value, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> paintControlTintsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->paintControlTints(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> scrollElementToRectCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, w, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(int, h, toInt32(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)));
    imp->scrollElementToRect(element, x, y, w, h, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> rangeFromLocationAndLengthCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, scope, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, rangeLocation, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, rangeLength, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    RefPtr<Range> result = imp->rangeFromLocationAndLength(scope, rangeLocation, rangeLength, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> locationFromRangeCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, scope, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Range*, range, V8Range::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Range::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    unsigned result = imp->locationFromRange(scope, range, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> lengthFromRangeCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Element*, scope, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Range*, range, V8Range::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Range::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    unsigned result = imp->lengthFromRange(scope, range, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> rangeAsTextCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Range*, range, V8Range::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Range::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->rangeAsText(range, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setDelegatesScrollingCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(bool, enabled, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->BooleanValue());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    imp->setDelegatesScrolling(enabled, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchPositionAdjustedToBestClickableNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined))) : 0);
    RefPtr<WebKitPoint> result = imp->touchPositionAdjustedToBestClickableNode(x, y, width, height, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchNodeAdjustedToBestClickableNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->touchNodeAdjustedToBestClickableNode(x, y, width, height, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchPositionAdjustedToBestContextMenuNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined))) : 0);
    RefPtr<WebKitPoint> result = imp->touchPositionAdjustedToBestContextMenuNode(x, y, width, height, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchNodeAdjustedToBestContextMenuNodeCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined))) : 0);
    RefPtr<Node> result = imp->touchNodeAdjustedToBestContextMenuNode(x, y, width, height, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> bestZoomableAreaForTouchPointCallback(const v8::Arguments& args)
{
    if (args.Length() < 5)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined))) : 0);
    RefPtr<ClientRect> result = imp->bestZoomableAreaForTouchPoint(x, y, width, height, document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> lastSpellCheckRequestSequenceCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    int result = imp->lastSpellCheckRequestSequence(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Integer(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> lastSpellCheckProcessedSequenceCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    int result = imp->lastSpellCheckProcessedSequence(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Integer(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> userPreferredLanguagesCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return v8Array(imp->userPreferredLanguages(), args.GetIsolate());
}

static v8::Handle<v8::Value> setUserPreferredLanguagesCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Vector<String>, languages, toNativeArray<String>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    imp->setUserPreferredLanguages(languages);
    return v8Undefined();
}

static v8::Handle<v8::Value> wheelEventHandlerCountCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    unsigned result = imp->wheelEventHandlerCount(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchEventHandlerCountCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    unsigned result = imp->touchEventHandlerCount(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> touchEventTargetClientRectsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    RefPtr<ClientRectList> result = imp->touchEventTargetClientRects(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> nodesFromRectCallback(const v8::Arguments& args)
{
    if (args.Length() < 9)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(unsigned, topPadding, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(unsigned, rightPadding, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)));
    V8TRYCATCH(unsigned, bottomPadding, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, DefaultIsUndefined)));
    V8TRYCATCH(unsigned, leftPadding, toUInt32(MAYBE_MISSING_PARAMETER(args, 6, DefaultIsUndefined)));
    V8TRYCATCH(bool, ignoreClipping, MAYBE_MISSING_PARAMETER(args, 7, DefaultIsUndefined)->BooleanValue());
    V8TRYCATCH(bool, allowShadowContent, MAYBE_MISSING_PARAMETER(args, 8, DefaultIsUndefined)->BooleanValue());
    RefPtr<NodeList> result = imp->nodesFromRect(document, x, y, topPadding, rightPadding, bottomPadding, leftPadding, ignoreClipping, allowShadowContent, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release(), args.Holder(), args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> emitInspectorDidBeginFrameCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    imp->emitInspectorDidBeginFrame();
    return v8Undefined();
}

static v8::Handle<v8::Value> emitInspectorDidCancelFrameCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    imp->emitInspectorDidCancelFrame();
    return v8Undefined();
}

static v8::Handle<v8::Value> hasSpellingMarkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, from, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, length, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    bool result = imp->hasSpellingMarker(document, from, length, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasGrammarMarkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, from, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, length, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    bool result = imp->hasGrammarMarker(document, from, length, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> hasAutocorrectedMarkerCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, from, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, length, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    bool result = imp->hasAutocorrectedMarker(document, from, length, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> numberOfScrollableAreasCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    unsigned result = imp->numberOfScrollableAreas(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8UnsignedInteger(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> isPageBoxVisibleCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(int, pageNumber, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    bool result = imp->isPageBoxVisible(document, pageNumber, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> suspendAnimationsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->suspendAnimations(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> resumeAnimationsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->resumeAnimations(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> layerTreeAsTextCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    if (args.Length() <= 1) {
        String result = imp->layerTreeAsText(document, ec);
        if (UNLIKELY(ec))
            goto fail;
        return v8String(result, args.GetIsolate());
    }
    V8TRYCATCH(int, flags, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    String result = imp->layerTreeAsText(document, flags, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> scrollingStateTreeAsTextCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->scrollingStateTreeAsText(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> mainThreadScrollingReasonsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->mainThreadScrollingReasons(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> repaintRectsAsTextCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->repaintRectsAsText(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> garbageCollectDocumentResourcesCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->garbageCollectDocumentResources(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> allowRoundingHacksCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    imp->allowRoundingHacks();
    return v8Undefined();
}

static v8::Handle<v8::Value> insertAuthorCSSCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, css, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->insertAuthorCSS(document, css);
    return v8Undefined();
}

static v8::Handle<v8::Value> insertUserCSSCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, css, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));
    imp->insertUserCSS(document, css);
    return v8Undefined();
}

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> numberOfLiveNodesCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return v8UnsignedInteger(imp->numberOfLiveNodes(), args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> numberOfLiveDocumentsCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return v8UnsignedInteger(imp->numberOfLiveDocuments(), args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> consoleMessageArgumentCountsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return v8Array(imp->consoleMessageArgumentCounts(document), args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> openDummyInspectorFrontendCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, url, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    return toV8(imp->openDummyInspectorFrontend(url), args.Holder(), args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> closeDummyInspectorFrontendCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    imp->closeDummyInspectorFrontend();
    return v8Undefined();
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> setInspectorResourcesDataSizeLimitsCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, maximumResourcesContentSize, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, maximumSingleResourceContentSize, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    imp->setInspectorResourcesDataSizeLimits(maximumResourcesContentSize, maximumSingleResourceContentSize, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

#if ENABLE(INSPECTOR)

static v8::Handle<v8::Value> setJavaScriptProfilingEnabledCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(bool, creates, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->BooleanValue());
    imp->setJavaScriptProfilingEnabled(creates, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

#endif // ENABLE(INSPECTOR)

static v8::Handle<v8::Value> counterValueCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return v8String(imp->counterValue(element), args.GetIsolate());
}

static v8::Handle<v8::Value> pageNumberCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    if (args.Length() <= 1) {
        return v8Integer(imp->pageNumber(element), args.GetIsolate());
    }
    V8TRYCATCH(float, pageWidth, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
    if (args.Length() <= 2) {
        return v8Integer(imp->pageNumber(element, pageWidth), args.GetIsolate());
    }
    V8TRYCATCH(float, pageHeight, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)->NumberValue()));
    return v8Integer(imp->pageNumber(element, pageWidth, pageHeight), args.GetIsolate());
}

static v8::Handle<v8::Value> iconURLsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return v8Array(imp->iconURLs(document), args.GetIsolate());
}

static v8::Handle<v8::Value> numberOfPagesCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    if (args.Length() <= 0) {
        return v8Integer(imp->numberOfPages(), args.GetIsolate());
    }
    V8TRYCATCH(double, pageWidthInPixels, static_cast<double>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->NumberValue()));
    if (args.Length() <= 1) {
        return v8Integer(imp->numberOfPages(pageWidthInPixels), args.GetIsolate());
    }
    V8TRYCATCH(double, pageHeightInPixels, static_cast<double>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));
    return v8Integer(imp->numberOfPages(pageWidthInPixels, pageHeightInPixels), args.GetIsolate());
}

static v8::Handle<v8::Value> pagePropertyCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, propertyName, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    V8TRYCATCH(int, pageNumber, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    String result = imp->pageProperty(propertyName, pageNumber, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> pageSizeAndMarginsInPixelsCallback(const v8::Arguments& args)
{
    if (args.Length() < 7)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(int, pageIndex, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
    V8TRYCATCH(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    V8TRYCATCH(int, marginTop, toInt32(MAYBE_MISSING_PARAMETER(args, 3, DefaultIsUndefined)));
    V8TRYCATCH(int, marginRight, toInt32(MAYBE_MISSING_PARAMETER(args, 4, DefaultIsUndefined)));
    V8TRYCATCH(int, marginBottom, toInt32(MAYBE_MISSING_PARAMETER(args, 5, DefaultIsUndefined)));
    V8TRYCATCH(int, marginLeft, toInt32(MAYBE_MISSING_PARAMETER(args, 6, DefaultIsUndefined)));
    String result = imp->pageSizeAndMarginsInPixels(pageIndex, width, height, marginTop, marginRight, marginBottom, marginLeft, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> setPageScaleFactorCallback(const v8::Arguments& args)
{
    if (args.Length() < 3)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(float, scaleFactor, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->NumberValue()));
    V8TRYCATCH(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    V8TRYCATCH(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)));
    imp->setPageScaleFactor(scaleFactor, x, y, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> webkitWillEnterFullScreenForElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    imp->webkitWillEnterFullScreenForElement(document, element);
    return v8Undefined();
}

static v8::Handle<v8::Value> webkitDidEnterFullScreenForElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    imp->webkitDidEnterFullScreenForElement(document, element);
    return v8Undefined();
}

static v8::Handle<v8::Value> webkitWillExitFullScreenForElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    imp->webkitWillExitFullScreenForElement(document, element);
    return v8Undefined();
}

static v8::Handle<v8::Value> webkitDidExitFullScreenForElementCallback(const v8::Arguments& args)
{
    if (args.Length() < 2)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    V8TRYCATCH(Element*, element, V8Element::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8Element::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);
    imp->webkitDidExitFullScreenForElement(document, element);
    return v8Undefined();
}

static v8::Handle<v8::Value> registerURLSchemeAsBypassingContentSecurityPolicyCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, scheme, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    imp->registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
    return v8Undefined();
}

static v8::Handle<v8::Value> removeURLSchemeRegisteredAsBypassingContentSecurityPolicyCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE(V8StringResource<>, scheme, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));
    imp->removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
    return v8Undefined();
}

static v8::Handle<v8::Value> mallocStatisticsCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return toV8(imp->mallocStatistics(), args.Holder(), args.GetIsolate());
}

static v8::Handle<v8::Value> typeConversionsCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return toV8(imp->typeConversions(), args.Holder(), args.GetIsolate());
}

static v8::Handle<v8::Value> getReferencedFilePathsCallback(const v8::Arguments& args)
{
    Internals* imp = V8Internals::toNative(args.Holder());
    return v8Array(imp->getReferencedFilePaths(), args.GetIsolate());
}

static v8::Handle<v8::Value> startTrackingRepaintsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->startTrackingRepaints(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> stopTrackingRepaintsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    imp->stopTrackingRepaints(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Undefined();
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> getCurrentCursorInfoCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    V8TRYCATCH(Document*, document, V8Document::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Document::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    String result = imp->getCurrentCursorInfo(document, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8String(result, args.GetIsolate());
    }
    fail:
    return setDOMException(ec, args.GetIsolate());
}

static v8::Handle<v8::Value> deserializeBufferCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(ArrayBuffer*, buffer, V8ArrayBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8ArrayBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
    return imp->deserializeBuffer(buffer) ? imp->deserializeBuffer(buffer)->deserialize() : v8::Handle<v8::Value>(v8Null(args.GetIsolate()));
}

static v8::Handle<v8::Value> serializeObjectCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    bool objDidThrow = false;
    RefPtr<SerializedScriptValue> obj = SerializedScriptValue::create(args[0], 0, 0, objDidThrow, args.GetIsolate());
    if (objDidThrow)
        return v8Undefined();
    return toV8(imp->serializeObject(obj), args.Holder(), args.GetIsolate());
}

static v8::Handle<v8::Value> setUsesOverlayScrollbarsCallback(const v8::Arguments& args)
{
    if (args.Length() < 1)
        return throwNotEnoughArgumentsError(args.GetIsolate());
    Internals* imp = V8Internals::toNative(args.Holder());
    V8TRYCATCH(bool, enabled, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)->BooleanValue());
    imp->setUsesOverlayScrollbars(enabled);
    return v8Undefined();
}

} // namespace InternalsV8Internal

static const V8DOMConfiguration::BatchedAttribute V8InternalsAttrs[] = {
    // Attribute 'pagePopupController' (Type: 'readonly attribute' ExtAttr: '')
    {"pagePopupController", InternalsV8Internal::pagePopupControllerAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    // Attribute 'settings' (Type: 'readonly attribute' ExtAttr: '')
    {"settings", InternalsV8Internal::settingsAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const V8DOMConfiguration::BatchedCallback V8InternalsCallbacks[] = {
    {"formControlStateOfPreviousHistoryItem", InternalsV8Internal::formControlStateOfPreviousHistoryItemCallback},
    {"setFormControlStateOfPreviousHistoryItem", InternalsV8Internal::setFormControlStateOfPreviousHistoryItemCallback},
    {"setEnableMockPagePopup", InternalsV8Internal::setEnableMockPagePopupCallback},
    {"setPagination", InternalsV8Internal::setPaginationCallback},
    {"userPreferredLanguages", InternalsV8Internal::userPreferredLanguagesCallback},
    {"emitInspectorDidBeginFrame", InternalsV8Internal::emitInspectorDidBeginFrameCallback},
    {"emitInspectorDidCancelFrame", InternalsV8Internal::emitInspectorDidCancelFrameCallback},
    {"layerTreeAsText", InternalsV8Internal::layerTreeAsTextCallback},
    {"allowRoundingHacks", InternalsV8Internal::allowRoundingHacksCallback},
#if ENABLE(INSPECTOR)
    {"numberOfLiveNodes", InternalsV8Internal::numberOfLiveNodesCallback},
#endif
#if ENABLE(INSPECTOR)
    {"numberOfLiveDocuments", InternalsV8Internal::numberOfLiveDocumentsCallback},
#endif
#if ENABLE(INSPECTOR)
    {"openDummyInspectorFrontend", InternalsV8Internal::openDummyInspectorFrontendCallback},
#endif
#if ENABLE(INSPECTOR)
    {"closeDummyInspectorFrontend", InternalsV8Internal::closeDummyInspectorFrontendCallback},
#endif
#if ENABLE(INSPECTOR)
    {"setInspectorResourcesDataSizeLimits", InternalsV8Internal::setInspectorResourcesDataSizeLimitsCallback},
#endif
#if ENABLE(INSPECTOR)
    {"setJavaScriptProfilingEnabled", InternalsV8Internal::setJavaScriptProfilingEnabledCallback},
#endif
    {"pageNumber", InternalsV8Internal::pageNumberCallback},
    {"numberOfPages", InternalsV8Internal::numberOfPagesCallback},
    {"pageProperty", InternalsV8Internal::pagePropertyCallback},
    {"pageSizeAndMarginsInPixels", InternalsV8Internal::pageSizeAndMarginsInPixelsCallback},
    {"setPageScaleFactor", InternalsV8Internal::setPageScaleFactorCallback},
    {"registerURLSchemeAsBypassingContentSecurityPolicy", InternalsV8Internal::registerURLSchemeAsBypassingContentSecurityPolicyCallback},
    {"removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", InternalsV8Internal::removeURLSchemeRegisteredAsBypassingContentSecurityPolicyCallback},
    {"mallocStatistics", InternalsV8Internal::mallocStatisticsCallback},
    {"typeConversions", InternalsV8Internal::typeConversionsCallback},
    {"getReferencedFilePaths", InternalsV8Internal::getReferencedFilePathsCallback},
    {"serializeObject", InternalsV8Internal::serializeObjectCallback},
    {"setUsesOverlayScrollbars", InternalsV8Internal::setUsesOverlayScrollbarsCallback},
};

static const V8DOMConfiguration::BatchedConstant V8InternalsConsts[] = {
    {"LAYER_TREE_INCLUDES_VISIBLE_RECTS", static_cast<signed int>(1)},
    {"LAYER_TREE_INCLUDES_TILE_CACHES", static_cast<signed int>(2)},
    {"LAYER_TREE_INCLUDES_REPAINT_RECTS", static_cast<signed int>(4)},
};


COMPILE_ASSERT(1 == Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS, InternalsEnumLAYER_TREE_INCLUDES_VISIBLE_RECTSIsWrongUseDoNotCheckConstants);
COMPILE_ASSERT(2 == Internals::LAYER_TREE_INCLUDES_TILE_CACHES, InternalsEnumLAYER_TREE_INCLUDES_TILE_CACHESIsWrongUseDoNotCheckConstants);
COMPILE_ASSERT(4 == Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS, InternalsEnumLAYER_TREE_INCLUDES_REPAINT_RECTSIsWrongUseDoNotCheckConstants);

static v8::Persistent<v8::FunctionTemplate> ConfigureV8InternalsTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature;
    defaultSignature = V8DOMConfiguration::configureTemplate(desc, "Internals", v8::Persistent<v8::FunctionTemplate>(), V8Internals::internalFieldCount,
        V8InternalsAttrs, WTF_ARRAY_LENGTH(V8InternalsAttrs),
        V8InternalsCallbacks, WTF_ARRAY_LENGTH(V8InternalsCallbacks));
    UNUSED_PARAM(defaultSignature); // In some cases, it will not be used.
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    UNUSED_PARAM(instance); // In some cases, it will not be used.
    UNUSED_PARAM(proto); // In some cases, it will not be used.
    

    // Custom Signature 'address'
    const int addressArgc = 1;
    v8::Handle<v8::FunctionTemplate> addressArgv[addressArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> addressSignature = v8::Signature::New(desc, addressArgc, addressArgv);
    proto->Set(v8::String::NewSymbol("address"), v8::FunctionTemplate::New(InternalsV8Internal::addressCallback, v8Undefined(), addressSignature));

    // Custom Signature 'elementRenderTreeAsText'
    const int elementRenderTreeAsTextArgc = 1;
    v8::Handle<v8::FunctionTemplate> elementRenderTreeAsTextArgv[elementRenderTreeAsTextArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> elementRenderTreeAsTextSignature = v8::Signature::New(desc, elementRenderTreeAsTextArgc, elementRenderTreeAsTextArgv);
    proto->Set(v8::String::NewSymbol("elementRenderTreeAsText"), v8::FunctionTemplate::New(InternalsV8Internal::elementRenderTreeAsTextCallback, v8Undefined(), elementRenderTreeAsTextSignature));

    // Custom Signature 'isPreloaded'
    const int isPreloadedArgc = 2;
    v8::Handle<v8::FunctionTemplate> isPreloadedArgv[isPreloadedArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> isPreloadedSignature = v8::Signature::New(desc, isPreloadedArgc, isPreloadedArgv);
    proto->Set(v8::String::NewSymbol("isPreloaded"), v8::FunctionTemplate::New(InternalsV8Internal::isPreloadedCallback, v8Undefined(), isPreloadedSignature));

    // Custom Signature 'numberOfScopedHTMLStyleChildren'
    const int numberOfScopedHTMLStyleChildrenArgc = 1;
    v8::Handle<v8::FunctionTemplate> numberOfScopedHTMLStyleChildrenArgv[numberOfScopedHTMLStyleChildrenArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> numberOfScopedHTMLStyleChildrenSignature = v8::Signature::New(desc, numberOfScopedHTMLStyleChildrenArgc, numberOfScopedHTMLStyleChildrenArgv);
    proto->Set(v8::String::NewSymbol("numberOfScopedHTMLStyleChildren"), v8::FunctionTemplate::New(InternalsV8Internal::numberOfScopedHTMLStyleChildrenCallback, v8Undefined(), numberOfScopedHTMLStyleChildrenSignature));

    // Custom Signature 'ensureShadowRoot'
    const int ensureShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> ensureShadowRootArgv[ensureShadowRootArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> ensureShadowRootSignature = v8::Signature::New(desc, ensureShadowRootArgc, ensureShadowRootArgv);
    proto->Set(v8::String::NewSymbol("ensureShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::ensureShadowRootCallback, v8Undefined(), ensureShadowRootSignature));

    // Custom Signature 'createShadowRoot'
    const int createShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> createShadowRootArgv[createShadowRootArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> createShadowRootSignature = v8::Signature::New(desc, createShadowRootArgc, createShadowRootArgv);
    proto->Set(v8::String::NewSymbol("createShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::createShadowRootCallback, v8Undefined(), createShadowRootSignature));

    // Custom Signature 'shadowRoot'
    const int shadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> shadowRootArgv[shadowRootArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> shadowRootSignature = v8::Signature::New(desc, shadowRootArgc, shadowRootArgv);
    proto->Set(v8::String::NewSymbol("shadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::shadowRootCallback, v8Undefined(), shadowRootSignature));

    // Custom Signature 'youngestShadowRoot'
    const int youngestShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> youngestShadowRootArgv[youngestShadowRootArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> youngestShadowRootSignature = v8::Signature::New(desc, youngestShadowRootArgc, youngestShadowRootArgv);
    proto->Set(v8::String::NewSymbol("youngestShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::youngestShadowRootCallback, v8Undefined(), youngestShadowRootSignature));

    // Custom Signature 'oldestShadowRoot'
    const int oldestShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> oldestShadowRootArgv[oldestShadowRootArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> oldestShadowRootSignature = v8::Signature::New(desc, oldestShadowRootArgc, oldestShadowRootArgv);
    proto->Set(v8::String::NewSymbol("oldestShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::oldestShadowRootCallback, v8Undefined(), oldestShadowRootSignature));

    // Custom Signature 'youngerShadowRoot'
    const int youngerShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> youngerShadowRootArgv[youngerShadowRootArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> youngerShadowRootSignature = v8::Signature::New(desc, youngerShadowRootArgc, youngerShadowRootArgv);
    proto->Set(v8::String::NewSymbol("youngerShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::youngerShadowRootCallback, v8Undefined(), youngerShadowRootSignature));

    // Custom Signature 'olderShadowRoot'
    const int olderShadowRootArgc = 1;
    v8::Handle<v8::FunctionTemplate> olderShadowRootArgv[olderShadowRootArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> olderShadowRootSignature = v8::Signature::New(desc, olderShadowRootArgc, olderShadowRootArgv);
    proto->Set(v8::String::NewSymbol("olderShadowRoot"), v8::FunctionTemplate::New(InternalsV8Internal::olderShadowRootCallback, v8Undefined(), olderShadowRootSignature));

    // Custom Signature 'shadowRootType'
    const int shadowRootTypeArgc = 1;
    v8::Handle<v8::FunctionTemplate> shadowRootTypeArgv[shadowRootTypeArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> shadowRootTypeSignature = v8::Signature::New(desc, shadowRootTypeArgc, shadowRootTypeArgv);
    proto->Set(v8::String::NewSymbol("shadowRootType"), v8::FunctionTemplate::New(InternalsV8Internal::shadowRootTypeCallback, v8Undefined(), shadowRootTypeSignature));

    // Custom Signature 'hasShadowInsertionPoint'
    const int hasShadowInsertionPointArgc = 1;
    v8::Handle<v8::FunctionTemplate> hasShadowInsertionPointArgv[hasShadowInsertionPointArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> hasShadowInsertionPointSignature = v8::Signature::New(desc, hasShadowInsertionPointArgc, hasShadowInsertionPointArgv);
    proto->Set(v8::String::NewSymbol("hasShadowInsertionPoint"), v8::FunctionTemplate::New(InternalsV8Internal::hasShadowInsertionPointCallback, v8Undefined(), hasShadowInsertionPointSignature));

    // Custom Signature 'hasContentElement'
    const int hasContentElementArgc = 1;
    v8::Handle<v8::FunctionTemplate> hasContentElementArgv[hasContentElementArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> hasContentElementSignature = v8::Signature::New(desc, hasContentElementArgc, hasContentElementArgv);
    proto->Set(v8::String::NewSymbol("hasContentElement"), v8::FunctionTemplate::New(InternalsV8Internal::hasContentElementCallback, v8Undefined(), hasContentElementSignature));

    // Custom Signature 'countElementShadow'
    const int countElementShadowArgc = 1;
    v8::Handle<v8::FunctionTemplate> countElementShadowArgv[countElementShadowArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> countElementShadowSignature = v8::Signature::New(desc, countElementShadowArgc, countElementShadowArgv);
    proto->Set(v8::String::NewSymbol("countElementShadow"), v8::FunctionTemplate::New(InternalsV8Internal::countElementShadowCallback, v8Undefined(), countElementShadowSignature));

    // Custom Signature 'includerFor'
    const int includerForArgc = 1;
    v8::Handle<v8::FunctionTemplate> includerForArgv[includerForArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> includerForSignature = v8::Signature::New(desc, includerForArgc, includerForArgv);
    proto->Set(v8::String::NewSymbol("includerFor"), v8::FunctionTemplate::New(InternalsV8Internal::includerForCallback, v8Undefined(), includerForSignature));

    // Custom Signature 'shadowPseudoId'
    const int shadowPseudoIdArgc = 1;
    v8::Handle<v8::FunctionTemplate> shadowPseudoIdArgv[shadowPseudoIdArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> shadowPseudoIdSignature = v8::Signature::New(desc, shadowPseudoIdArgc, shadowPseudoIdArgv);
    proto->Set(v8::String::NewSymbol("shadowPseudoId"), v8::FunctionTemplate::New(InternalsV8Internal::shadowPseudoIdCallback, v8Undefined(), shadowPseudoIdSignature));

    // Custom Signature 'setShadowPseudoId'
    const int setShadowPseudoIdArgc = 2;
    v8::Handle<v8::FunctionTemplate> setShadowPseudoIdArgv[setShadowPseudoIdArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setShadowPseudoIdSignature = v8::Signature::New(desc, setShadowPseudoIdArgc, setShadowPseudoIdArgv);
    proto->Set(v8::String::NewSymbol("setShadowPseudoId"), v8::FunctionTemplate::New(InternalsV8Internal::setShadowPseudoIdCallback, v8Undefined(), setShadowPseudoIdSignature));

    // Custom Signature 'createContentElement'
    const int createContentElementArgc = 1;
    v8::Handle<v8::FunctionTemplate> createContentElementArgv[createContentElementArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> createContentElementSignature = v8::Signature::New(desc, createContentElementArgc, createContentElementArgv);
    proto->Set(v8::String::NewSymbol("createContentElement"), v8::FunctionTemplate::New(InternalsV8Internal::createContentElementCallback, v8Undefined(), createContentElementSignature));

    // Custom Signature 'isValidContentSelect'
    const int isValidContentSelectArgc = 1;
    v8::Handle<v8::FunctionTemplate> isValidContentSelectArgv[isValidContentSelectArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> isValidContentSelectSignature = v8::Signature::New(desc, isValidContentSelectArgc, isValidContentSelectArgv);
    proto->Set(v8::String::NewSymbol("isValidContentSelect"), v8::FunctionTemplate::New(InternalsV8Internal::isValidContentSelectCallback, v8Undefined(), isValidContentSelectSignature));

    // Custom Signature 'treeScopeRootNode'
    const int treeScopeRootNodeArgc = 1;
    v8::Handle<v8::FunctionTemplate> treeScopeRootNodeArgv[treeScopeRootNodeArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> treeScopeRootNodeSignature = v8::Signature::New(desc, treeScopeRootNodeArgc, treeScopeRootNodeArgv);
    proto->Set(v8::String::NewSymbol("treeScopeRootNode"), v8::FunctionTemplate::New(InternalsV8Internal::treeScopeRootNodeCallback, v8Undefined(), treeScopeRootNodeSignature));

    // Custom Signature 'parentTreeScope'
    const int parentTreeScopeArgc = 1;
    v8::Handle<v8::FunctionTemplate> parentTreeScopeArgv[parentTreeScopeArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> parentTreeScopeSignature = v8::Signature::New(desc, parentTreeScopeArgc, parentTreeScopeArgv);
    proto->Set(v8::String::NewSymbol("parentTreeScope"), v8::FunctionTemplate::New(InternalsV8Internal::parentTreeScopeCallback, v8Undefined(), parentTreeScopeSignature));

    // Custom Signature 'hasSelectorForIdInShadow'
    const int hasSelectorForIdInShadowArgc = 2;
    v8::Handle<v8::FunctionTemplate> hasSelectorForIdInShadowArgv[hasSelectorForIdInShadowArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasSelectorForIdInShadowSignature = v8::Signature::New(desc, hasSelectorForIdInShadowArgc, hasSelectorForIdInShadowArgv);
    proto->Set(v8::String::NewSymbol("hasSelectorForIdInShadow"), v8::FunctionTemplate::New(InternalsV8Internal::hasSelectorForIdInShadowCallback, v8Undefined(), hasSelectorForIdInShadowSignature));

    // Custom Signature 'hasSelectorForClassInShadow'
    const int hasSelectorForClassInShadowArgc = 2;
    v8::Handle<v8::FunctionTemplate> hasSelectorForClassInShadowArgv[hasSelectorForClassInShadowArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasSelectorForClassInShadowSignature = v8::Signature::New(desc, hasSelectorForClassInShadowArgc, hasSelectorForClassInShadowArgv);
    proto->Set(v8::String::NewSymbol("hasSelectorForClassInShadow"), v8::FunctionTemplate::New(InternalsV8Internal::hasSelectorForClassInShadowCallback, v8Undefined(), hasSelectorForClassInShadowSignature));

    // Custom Signature 'hasSelectorForAttributeInShadow'
    const int hasSelectorForAttributeInShadowArgc = 2;
    v8::Handle<v8::FunctionTemplate> hasSelectorForAttributeInShadowArgv[hasSelectorForAttributeInShadowArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasSelectorForAttributeInShadowSignature = v8::Signature::New(desc, hasSelectorForAttributeInShadowArgc, hasSelectorForAttributeInShadowArgv);
    proto->Set(v8::String::NewSymbol("hasSelectorForAttributeInShadow"), v8::FunctionTemplate::New(InternalsV8Internal::hasSelectorForAttributeInShadowCallback, v8Undefined(), hasSelectorForAttributeInShadowSignature));

    // Custom Signature 'hasSelectorForPseudoClassInShadow'
    const int hasSelectorForPseudoClassInShadowArgc = 2;
    v8::Handle<v8::FunctionTemplate> hasSelectorForPseudoClassInShadowArgv[hasSelectorForPseudoClassInShadowArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasSelectorForPseudoClassInShadowSignature = v8::Signature::New(desc, hasSelectorForPseudoClassInShadowArgc, hasSelectorForPseudoClassInShadowArgv);
    proto->Set(v8::String::NewSymbol("hasSelectorForPseudoClassInShadow"), v8::FunctionTemplate::New(InternalsV8Internal::hasSelectorForPseudoClassInShadowCallback, v8Undefined(), hasSelectorForPseudoClassInShadowSignature));

    // Custom Signature 'pauseAnimationAtTimeOnPseudoElement'
    const int pauseAnimationAtTimeOnPseudoElementArgc = 4;
    v8::Handle<v8::FunctionTemplate> pauseAnimationAtTimeOnPseudoElementArgv[pauseAnimationAtTimeOnPseudoElementArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> pauseAnimationAtTimeOnPseudoElementSignature = v8::Signature::New(desc, pauseAnimationAtTimeOnPseudoElementArgc, pauseAnimationAtTimeOnPseudoElementArgv);
    proto->Set(v8::String::NewSymbol("pauseAnimationAtTimeOnPseudoElement"), v8::FunctionTemplate::New(InternalsV8Internal::pauseAnimationAtTimeOnPseudoElementCallback, v8Undefined(), pauseAnimationAtTimeOnPseudoElementSignature));

    // Custom Signature 'pauseTransitionAtTimeOnPseudoElement'
    const int pauseTransitionAtTimeOnPseudoElementArgc = 4;
    v8::Handle<v8::FunctionTemplate> pauseTransitionAtTimeOnPseudoElementArgv[pauseTransitionAtTimeOnPseudoElementArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> pauseTransitionAtTimeOnPseudoElementSignature = v8::Signature::New(desc, pauseTransitionAtTimeOnPseudoElementArgc, pauseTransitionAtTimeOnPseudoElementArgv);
    proto->Set(v8::String::NewSymbol("pauseTransitionAtTimeOnPseudoElement"), v8::FunctionTemplate::New(InternalsV8Internal::pauseTransitionAtTimeOnPseudoElementCallback, v8Undefined(), pauseTransitionAtTimeOnPseudoElementSignature));

    // Custom Signature 'nextSiblingByWalker'
    const int nextSiblingByWalkerArgc = 1;
    v8::Handle<v8::FunctionTemplate> nextSiblingByWalkerArgv[nextSiblingByWalkerArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> nextSiblingByWalkerSignature = v8::Signature::New(desc, nextSiblingByWalkerArgc, nextSiblingByWalkerArgv);
    proto->Set(v8::String::NewSymbol("nextSiblingByWalker"), v8::FunctionTemplate::New(InternalsV8Internal::nextSiblingByWalkerCallback, v8Undefined(), nextSiblingByWalkerSignature));

    // Custom Signature 'firstChildByWalker'
    const int firstChildByWalkerArgc = 1;
    v8::Handle<v8::FunctionTemplate> firstChildByWalkerArgv[firstChildByWalkerArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> firstChildByWalkerSignature = v8::Signature::New(desc, firstChildByWalkerArgc, firstChildByWalkerArgv);
    proto->Set(v8::String::NewSymbol("firstChildByWalker"), v8::FunctionTemplate::New(InternalsV8Internal::firstChildByWalkerCallback, v8Undefined(), firstChildByWalkerSignature));

    // Custom Signature 'lastChildByWalker'
    const int lastChildByWalkerArgc = 1;
    v8::Handle<v8::FunctionTemplate> lastChildByWalkerArgv[lastChildByWalkerArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> lastChildByWalkerSignature = v8::Signature::New(desc, lastChildByWalkerArgc, lastChildByWalkerArgv);
    proto->Set(v8::String::NewSymbol("lastChildByWalker"), v8::FunctionTemplate::New(InternalsV8Internal::lastChildByWalkerCallback, v8Undefined(), lastChildByWalkerSignature));

    // Custom Signature 'nextNodeByWalker'
    const int nextNodeByWalkerArgc = 1;
    v8::Handle<v8::FunctionTemplate> nextNodeByWalkerArgv[nextNodeByWalkerArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> nextNodeByWalkerSignature = v8::Signature::New(desc, nextNodeByWalkerArgc, nextNodeByWalkerArgv);
    proto->Set(v8::String::NewSymbol("nextNodeByWalker"), v8::FunctionTemplate::New(InternalsV8Internal::nextNodeByWalkerCallback, v8Undefined(), nextNodeByWalkerSignature));

    // Custom Signature 'previousNodeByWalker'
    const int previousNodeByWalkerArgc = 1;
    v8::Handle<v8::FunctionTemplate> previousNodeByWalkerArgv[previousNodeByWalkerArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> previousNodeByWalkerSignature = v8::Signature::New(desc, previousNodeByWalkerArgc, previousNodeByWalkerArgv);
    proto->Set(v8::String::NewSymbol("previousNodeByWalker"), v8::FunctionTemplate::New(InternalsV8Internal::previousNodeByWalkerCallback, v8Undefined(), previousNodeByWalkerSignature));

    // Custom Signature 'attached'
    const int attachedArgc = 1;
    v8::Handle<v8::FunctionTemplate> attachedArgv[attachedArgc] = { V8Node::GetRawTemplate() };
    v8::Handle<v8::Signature> attachedSignature = v8::Signature::New(desc, attachedArgc, attachedArgv);
    proto->Set(v8::String::NewSymbol("attached"), v8::FunctionTemplate::New(InternalsV8Internal::attachedCallback, v8Undefined(), attachedSignature));

    // Custom Signature 'visiblePlaceholder'
    const int visiblePlaceholderArgc = 1;
    v8::Handle<v8::FunctionTemplate> visiblePlaceholderArgv[visiblePlaceholderArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> visiblePlaceholderSignature = v8::Signature::New(desc, visiblePlaceholderArgc, visiblePlaceholderArgv);
    proto->Set(v8::String::NewSymbol("visiblePlaceholder"), v8::FunctionTemplate::New(InternalsV8Internal::visiblePlaceholderCallback, v8Undefined(), visiblePlaceholderSignature));

    // Custom Signature 'selectColorInColorChooser'
    const int selectColorInColorChooserArgc = 2;
    v8::Handle<v8::FunctionTemplate> selectColorInColorChooserArgv[selectColorInColorChooserArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> selectColorInColorChooserSignature = v8::Signature::New(desc, selectColorInColorChooserArgc, selectColorInColorChooserArgv);
    proto->Set(v8::String::NewSymbol("selectColorInColorChooser"), v8::FunctionTemplate::New(InternalsV8Internal::selectColorInColorChooserCallback, v8Undefined(), selectColorInColorChooserSignature));

    // Custom Signature 'absoluteCaretBounds'
    const int absoluteCaretBoundsArgc = 1;
    v8::Handle<v8::FunctionTemplate> absoluteCaretBoundsArgv[absoluteCaretBoundsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> absoluteCaretBoundsSignature = v8::Signature::New(desc, absoluteCaretBoundsArgc, absoluteCaretBoundsArgv);
    proto->Set(v8::String::NewSymbol("absoluteCaretBounds"), v8::FunctionTemplate::New(InternalsV8Internal::absoluteCaretBoundsCallback, v8Undefined(), absoluteCaretBoundsSignature));

    // Custom Signature 'boundingBox'
    const int boundingBoxArgc = 1;
    v8::Handle<v8::FunctionTemplate> boundingBoxArgv[boundingBoxArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> boundingBoxSignature = v8::Signature::New(desc, boundingBoxArgc, boundingBoxArgv);
    proto->Set(v8::String::NewSymbol("boundingBox"), v8::FunctionTemplate::New(InternalsV8Internal::boundingBoxCallback, v8Undefined(), boundingBoxSignature));

    // Custom Signature 'inspectorHighlightRects'
    const int inspectorHighlightRectsArgc = 1;
    v8::Handle<v8::FunctionTemplate> inspectorHighlightRectsArgv[inspectorHighlightRectsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> inspectorHighlightRectsSignature = v8::Signature::New(desc, inspectorHighlightRectsArgc, inspectorHighlightRectsArgv);
    proto->Set(v8::String::NewSymbol("inspectorHighlightRects"), v8::FunctionTemplate::New(InternalsV8Internal::inspectorHighlightRectsCallback, v8Undefined(), inspectorHighlightRectsSignature));

    // Custom Signature 'setBackgroundBlurOnNode'
    const int setBackgroundBlurOnNodeArgc = 2;
    v8::Handle<v8::FunctionTemplate> setBackgroundBlurOnNodeArgv[setBackgroundBlurOnNodeArgc] = { V8Node::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setBackgroundBlurOnNodeSignature = v8::Signature::New(desc, setBackgroundBlurOnNodeArgc, setBackgroundBlurOnNodeArgv);
    proto->Set(v8::String::NewSymbol("setBackgroundBlurOnNode"), v8::FunctionTemplate::New(InternalsV8Internal::setBackgroundBlurOnNodeCallback, v8Undefined(), setBackgroundBlurOnNodeSignature));

    // Custom Signature 'markerCountForNode'
    const int markerCountForNodeArgc = 2;
    v8::Handle<v8::FunctionTemplate> markerCountForNodeArgv[markerCountForNodeArgc] = { V8Node::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> markerCountForNodeSignature = v8::Signature::New(desc, markerCountForNodeArgc, markerCountForNodeArgv);
    proto->Set(v8::String::NewSymbol("markerCountForNode"), v8::FunctionTemplate::New(InternalsV8Internal::markerCountForNodeCallback, v8Undefined(), markerCountForNodeSignature));

    // Custom Signature 'markerRangeForNode'
    const int markerRangeForNodeArgc = 3;
    v8::Handle<v8::FunctionTemplate> markerRangeForNodeArgv[markerRangeForNodeArgc] = { V8Node::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> markerRangeForNodeSignature = v8::Signature::New(desc, markerRangeForNodeArgc, markerRangeForNodeArgv);
    proto->Set(v8::String::NewSymbol("markerRangeForNode"), v8::FunctionTemplate::New(InternalsV8Internal::markerRangeForNodeCallback, v8Undefined(), markerRangeForNodeSignature));

    // Custom Signature 'markerDescriptionForNode'
    const int markerDescriptionForNodeArgc = 3;
    v8::Handle<v8::FunctionTemplate> markerDescriptionForNodeArgv[markerDescriptionForNodeArgc] = { V8Node::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> markerDescriptionForNodeSignature = v8::Signature::New(desc, markerDescriptionForNodeArgc, markerDescriptionForNodeArgv);
    proto->Set(v8::String::NewSymbol("markerDescriptionForNode"), v8::FunctionTemplate::New(InternalsV8Internal::markerDescriptionForNodeCallback, v8Undefined(), markerDescriptionForNodeSignature));

    // Custom Signature 'addTextMatchMarker'
    const int addTextMatchMarkerArgc = 2;
    v8::Handle<v8::FunctionTemplate> addTextMatchMarkerArgv[addTextMatchMarkerArgc] = { V8Range::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> addTextMatchMarkerSignature = v8::Signature::New(desc, addTextMatchMarkerArgc, addTextMatchMarkerArgv);
    proto->Set(v8::String::NewSymbol("addTextMatchMarker"), v8::FunctionTemplate::New(InternalsV8Internal::addTextMatchMarkerCallback, v8Undefined(), addTextMatchMarkerSignature));

    // Custom Signature 'setScrollViewPosition'
    const int setScrollViewPositionArgc = 3;
    v8::Handle<v8::FunctionTemplate> setScrollViewPositionArgv[setScrollViewPositionArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setScrollViewPositionSignature = v8::Signature::New(desc, setScrollViewPositionArgc, setScrollViewPositionArgv);
    proto->Set(v8::String::NewSymbol("setScrollViewPosition"), v8::FunctionTemplate::New(InternalsV8Internal::setScrollViewPositionCallback, v8Undefined(), setScrollViewPositionSignature));

    // Custom Signature 'configurationForViewport'
    const int configurationForViewportArgc = 6;
    v8::Handle<v8::FunctionTemplate> configurationForViewportArgv[configurationForViewportArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> configurationForViewportSignature = v8::Signature::New(desc, configurationForViewportArgc, configurationForViewportArgv);
    proto->Set(v8::String::NewSymbol("configurationForViewport"), v8::FunctionTemplate::New(InternalsV8Internal::configurationForViewportCallback, v8Undefined(), configurationForViewportSignature));

    // Custom Signature 'wasLastChangeUserEdit'
    const int wasLastChangeUserEditArgc = 1;
    v8::Handle<v8::FunctionTemplate> wasLastChangeUserEditArgv[wasLastChangeUserEditArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> wasLastChangeUserEditSignature = v8::Signature::New(desc, wasLastChangeUserEditArgc, wasLastChangeUserEditArgv);
    proto->Set(v8::String::NewSymbol("wasLastChangeUserEdit"), v8::FunctionTemplate::New(InternalsV8Internal::wasLastChangeUserEditCallback, v8Undefined(), wasLastChangeUserEditSignature));

    // Custom Signature 'suggestedValue'
    const int suggestedValueArgc = 1;
    v8::Handle<v8::FunctionTemplate> suggestedValueArgv[suggestedValueArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> suggestedValueSignature = v8::Signature::New(desc, suggestedValueArgc, suggestedValueArgv);
    proto->Set(v8::String::NewSymbol("suggestedValue"), v8::FunctionTemplate::New(InternalsV8Internal::suggestedValueCallback, v8Undefined(), suggestedValueSignature));

    // Custom Signature 'setSuggestedValue'
    const int setSuggestedValueArgc = 2;
    v8::Handle<v8::FunctionTemplate> setSuggestedValueArgv[setSuggestedValueArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setSuggestedValueSignature = v8::Signature::New(desc, setSuggestedValueArgc, setSuggestedValueArgv);
    proto->Set(v8::String::NewSymbol("setSuggestedValue"), v8::FunctionTemplate::New(InternalsV8Internal::setSuggestedValueCallback, v8Undefined(), setSuggestedValueSignature));

    // Custom Signature 'setEditingValue'
    const int setEditingValueArgc = 2;
    v8::Handle<v8::FunctionTemplate> setEditingValueArgv[setEditingValueArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setEditingValueSignature = v8::Signature::New(desc, setEditingValueArgc, setEditingValueArgv);
    proto->Set(v8::String::NewSymbol("setEditingValue"), v8::FunctionTemplate::New(InternalsV8Internal::setEditingValueCallback, v8Undefined(), setEditingValueSignature));

    // Custom Signature 'paintControlTints'
    const int paintControlTintsArgc = 1;
    v8::Handle<v8::FunctionTemplate> paintControlTintsArgv[paintControlTintsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> paintControlTintsSignature = v8::Signature::New(desc, paintControlTintsArgc, paintControlTintsArgv);
    proto->Set(v8::String::NewSymbol("paintControlTints"), v8::FunctionTemplate::New(InternalsV8Internal::paintControlTintsCallback, v8Undefined(), paintControlTintsSignature));

    // Custom Signature 'scrollElementToRect'
    const int scrollElementToRectArgc = 5;
    v8::Handle<v8::FunctionTemplate> scrollElementToRectArgv[scrollElementToRectArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> scrollElementToRectSignature = v8::Signature::New(desc, scrollElementToRectArgc, scrollElementToRectArgv);
    proto->Set(v8::String::NewSymbol("scrollElementToRect"), v8::FunctionTemplate::New(InternalsV8Internal::scrollElementToRectCallback, v8Undefined(), scrollElementToRectSignature));

    // Custom Signature 'rangeFromLocationAndLength'
    const int rangeFromLocationAndLengthArgc = 3;
    v8::Handle<v8::FunctionTemplate> rangeFromLocationAndLengthArgv[rangeFromLocationAndLengthArgc] = { V8Element::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> rangeFromLocationAndLengthSignature = v8::Signature::New(desc, rangeFromLocationAndLengthArgc, rangeFromLocationAndLengthArgv);
    proto->Set(v8::String::NewSymbol("rangeFromLocationAndLength"), v8::FunctionTemplate::New(InternalsV8Internal::rangeFromLocationAndLengthCallback, v8Undefined(), rangeFromLocationAndLengthSignature));

    // Custom Signature 'locationFromRange'
    const int locationFromRangeArgc = 2;
    v8::Handle<v8::FunctionTemplate> locationFromRangeArgv[locationFromRangeArgc] = { V8Element::GetRawTemplate(), V8Range::GetRawTemplate() };
    v8::Handle<v8::Signature> locationFromRangeSignature = v8::Signature::New(desc, locationFromRangeArgc, locationFromRangeArgv);
    proto->Set(v8::String::NewSymbol("locationFromRange"), v8::FunctionTemplate::New(InternalsV8Internal::locationFromRangeCallback, v8Undefined(), locationFromRangeSignature));

    // Custom Signature 'lengthFromRange'
    const int lengthFromRangeArgc = 2;
    v8::Handle<v8::FunctionTemplate> lengthFromRangeArgv[lengthFromRangeArgc] = { V8Element::GetRawTemplate(), V8Range::GetRawTemplate() };
    v8::Handle<v8::Signature> lengthFromRangeSignature = v8::Signature::New(desc, lengthFromRangeArgc, lengthFromRangeArgv);
    proto->Set(v8::String::NewSymbol("lengthFromRange"), v8::FunctionTemplate::New(InternalsV8Internal::lengthFromRangeCallback, v8Undefined(), lengthFromRangeSignature));

    // Custom Signature 'rangeAsText'
    const int rangeAsTextArgc = 1;
    v8::Handle<v8::FunctionTemplate> rangeAsTextArgv[rangeAsTextArgc] = { V8Range::GetRawTemplate() };
    v8::Handle<v8::Signature> rangeAsTextSignature = v8::Signature::New(desc, rangeAsTextArgc, rangeAsTextArgv);
    proto->Set(v8::String::NewSymbol("rangeAsText"), v8::FunctionTemplate::New(InternalsV8Internal::rangeAsTextCallback, v8Undefined(), rangeAsTextSignature));

    // Custom Signature 'setDelegatesScrolling'
    const int setDelegatesScrollingArgc = 2;
    v8::Handle<v8::FunctionTemplate> setDelegatesScrollingArgv[setDelegatesScrollingArgc] = { v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> setDelegatesScrollingSignature = v8::Signature::New(desc, setDelegatesScrollingArgc, setDelegatesScrollingArgv);
    proto->Set(v8::String::NewSymbol("setDelegatesScrolling"), v8::FunctionTemplate::New(InternalsV8Internal::setDelegatesScrollingCallback, v8Undefined(), setDelegatesScrollingSignature));

    // Custom Signature 'touchPositionAdjustedToBestClickableNode'
    const int touchPositionAdjustedToBestClickableNodeArgc = 5;
    v8::Handle<v8::FunctionTemplate> touchPositionAdjustedToBestClickableNodeArgv[touchPositionAdjustedToBestClickableNodeArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchPositionAdjustedToBestClickableNodeSignature = v8::Signature::New(desc, touchPositionAdjustedToBestClickableNodeArgc, touchPositionAdjustedToBestClickableNodeArgv);
    proto->Set(v8::String::NewSymbol("touchPositionAdjustedToBestClickableNode"), v8::FunctionTemplate::New(InternalsV8Internal::touchPositionAdjustedToBestClickableNodeCallback, v8Undefined(), touchPositionAdjustedToBestClickableNodeSignature));

    // Custom Signature 'touchNodeAdjustedToBestClickableNode'
    const int touchNodeAdjustedToBestClickableNodeArgc = 5;
    v8::Handle<v8::FunctionTemplate> touchNodeAdjustedToBestClickableNodeArgv[touchNodeAdjustedToBestClickableNodeArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchNodeAdjustedToBestClickableNodeSignature = v8::Signature::New(desc, touchNodeAdjustedToBestClickableNodeArgc, touchNodeAdjustedToBestClickableNodeArgv);
    proto->Set(v8::String::NewSymbol("touchNodeAdjustedToBestClickableNode"), v8::FunctionTemplate::New(InternalsV8Internal::touchNodeAdjustedToBestClickableNodeCallback, v8Undefined(), touchNodeAdjustedToBestClickableNodeSignature));

    // Custom Signature 'touchPositionAdjustedToBestContextMenuNode'
    const int touchPositionAdjustedToBestContextMenuNodeArgc = 5;
    v8::Handle<v8::FunctionTemplate> touchPositionAdjustedToBestContextMenuNodeArgv[touchPositionAdjustedToBestContextMenuNodeArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchPositionAdjustedToBestContextMenuNodeSignature = v8::Signature::New(desc, touchPositionAdjustedToBestContextMenuNodeArgc, touchPositionAdjustedToBestContextMenuNodeArgv);
    proto->Set(v8::String::NewSymbol("touchPositionAdjustedToBestContextMenuNode"), v8::FunctionTemplate::New(InternalsV8Internal::touchPositionAdjustedToBestContextMenuNodeCallback, v8Undefined(), touchPositionAdjustedToBestContextMenuNodeSignature));

    // Custom Signature 'touchNodeAdjustedToBestContextMenuNode'
    const int touchNodeAdjustedToBestContextMenuNodeArgc = 5;
    v8::Handle<v8::FunctionTemplate> touchNodeAdjustedToBestContextMenuNodeArgv[touchNodeAdjustedToBestContextMenuNodeArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchNodeAdjustedToBestContextMenuNodeSignature = v8::Signature::New(desc, touchNodeAdjustedToBestContextMenuNodeArgc, touchNodeAdjustedToBestContextMenuNodeArgv);
    proto->Set(v8::String::NewSymbol("touchNodeAdjustedToBestContextMenuNode"), v8::FunctionTemplate::New(InternalsV8Internal::touchNodeAdjustedToBestContextMenuNodeCallback, v8Undefined(), touchNodeAdjustedToBestContextMenuNodeSignature));

    // Custom Signature 'bestZoomableAreaForTouchPoint'
    const int bestZoomableAreaForTouchPointArgc = 5;
    v8::Handle<v8::FunctionTemplate> bestZoomableAreaForTouchPointArgv[bestZoomableAreaForTouchPointArgc] = { v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> bestZoomableAreaForTouchPointSignature = v8::Signature::New(desc, bestZoomableAreaForTouchPointArgc, bestZoomableAreaForTouchPointArgv);
    proto->Set(v8::String::NewSymbol("bestZoomableAreaForTouchPoint"), v8::FunctionTemplate::New(InternalsV8Internal::bestZoomableAreaForTouchPointCallback, v8Undefined(), bestZoomableAreaForTouchPointSignature));

    // Custom Signature 'lastSpellCheckRequestSequence'
    const int lastSpellCheckRequestSequenceArgc = 1;
    v8::Handle<v8::FunctionTemplate> lastSpellCheckRequestSequenceArgv[lastSpellCheckRequestSequenceArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> lastSpellCheckRequestSequenceSignature = v8::Signature::New(desc, lastSpellCheckRequestSequenceArgc, lastSpellCheckRequestSequenceArgv);
    proto->Set(v8::String::NewSymbol("lastSpellCheckRequestSequence"), v8::FunctionTemplate::New(InternalsV8Internal::lastSpellCheckRequestSequenceCallback, v8Undefined(), lastSpellCheckRequestSequenceSignature));

    // Custom Signature 'lastSpellCheckProcessedSequence'
    const int lastSpellCheckProcessedSequenceArgc = 1;
    v8::Handle<v8::FunctionTemplate> lastSpellCheckProcessedSequenceArgv[lastSpellCheckProcessedSequenceArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> lastSpellCheckProcessedSequenceSignature = v8::Signature::New(desc, lastSpellCheckProcessedSequenceArgc, lastSpellCheckProcessedSequenceArgv);
    proto->Set(v8::String::NewSymbol("lastSpellCheckProcessedSequence"), v8::FunctionTemplate::New(InternalsV8Internal::lastSpellCheckProcessedSequenceCallback, v8Undefined(), lastSpellCheckProcessedSequenceSignature));

    // Custom Signature 'setUserPreferredLanguages'
    const int setUserPreferredLanguagesArgc = 1;
    v8::Handle<v8::FunctionTemplate> setUserPreferredLanguagesArgv[setUserPreferredLanguagesArgc] = { v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> setUserPreferredLanguagesSignature = v8::Signature::New(desc, setUserPreferredLanguagesArgc, setUserPreferredLanguagesArgv);
    proto->Set(v8::String::NewSymbol("setUserPreferredLanguages"), v8::FunctionTemplate::New(InternalsV8Internal::setUserPreferredLanguagesCallback, v8Undefined(), setUserPreferredLanguagesSignature));

    // Custom Signature 'wheelEventHandlerCount'
    const int wheelEventHandlerCountArgc = 1;
    v8::Handle<v8::FunctionTemplate> wheelEventHandlerCountArgv[wheelEventHandlerCountArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> wheelEventHandlerCountSignature = v8::Signature::New(desc, wheelEventHandlerCountArgc, wheelEventHandlerCountArgv);
    proto->Set(v8::String::NewSymbol("wheelEventHandlerCount"), v8::FunctionTemplate::New(InternalsV8Internal::wheelEventHandlerCountCallback, v8Undefined(), wheelEventHandlerCountSignature));

    // Custom Signature 'touchEventHandlerCount'
    const int touchEventHandlerCountArgc = 1;
    v8::Handle<v8::FunctionTemplate> touchEventHandlerCountArgv[touchEventHandlerCountArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchEventHandlerCountSignature = v8::Signature::New(desc, touchEventHandlerCountArgc, touchEventHandlerCountArgv);
    proto->Set(v8::String::NewSymbol("touchEventHandlerCount"), v8::FunctionTemplate::New(InternalsV8Internal::touchEventHandlerCountCallback, v8Undefined(), touchEventHandlerCountSignature));

    // Custom Signature 'touchEventTargetClientRects'
    const int touchEventTargetClientRectsArgc = 1;
    v8::Handle<v8::FunctionTemplate> touchEventTargetClientRectsArgv[touchEventTargetClientRectsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> touchEventTargetClientRectsSignature = v8::Signature::New(desc, touchEventTargetClientRectsArgc, touchEventTargetClientRectsArgv);
    proto->Set(v8::String::NewSymbol("touchEventTargetClientRects"), v8::FunctionTemplate::New(InternalsV8Internal::touchEventTargetClientRectsCallback, v8Undefined(), touchEventTargetClientRectsSignature));

    // Custom Signature 'nodesFromRect'
    const int nodesFromRectArgc = 9;
    v8::Handle<v8::FunctionTemplate> nodesFromRectArgv[nodesFromRectArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> nodesFromRectSignature = v8::Signature::New(desc, nodesFromRectArgc, nodesFromRectArgv);
    proto->Set(v8::String::NewSymbol("nodesFromRect"), v8::FunctionTemplate::New(InternalsV8Internal::nodesFromRectCallback, v8Undefined(), nodesFromRectSignature));

    // Custom Signature 'hasSpellingMarker'
    const int hasSpellingMarkerArgc = 3;
    v8::Handle<v8::FunctionTemplate> hasSpellingMarkerArgv[hasSpellingMarkerArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasSpellingMarkerSignature = v8::Signature::New(desc, hasSpellingMarkerArgc, hasSpellingMarkerArgv);
    proto->Set(v8::String::NewSymbol("hasSpellingMarker"), v8::FunctionTemplate::New(InternalsV8Internal::hasSpellingMarkerCallback, v8Undefined(), hasSpellingMarkerSignature));

    // Custom Signature 'hasGrammarMarker'
    const int hasGrammarMarkerArgc = 3;
    v8::Handle<v8::FunctionTemplate> hasGrammarMarkerArgv[hasGrammarMarkerArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasGrammarMarkerSignature = v8::Signature::New(desc, hasGrammarMarkerArgc, hasGrammarMarkerArgv);
    proto->Set(v8::String::NewSymbol("hasGrammarMarker"), v8::FunctionTemplate::New(InternalsV8Internal::hasGrammarMarkerCallback, v8Undefined(), hasGrammarMarkerSignature));

    // Custom Signature 'hasAutocorrectedMarker'
    const int hasAutocorrectedMarkerArgc = 3;
    v8::Handle<v8::FunctionTemplate> hasAutocorrectedMarkerArgv[hasAutocorrectedMarkerArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> hasAutocorrectedMarkerSignature = v8::Signature::New(desc, hasAutocorrectedMarkerArgc, hasAutocorrectedMarkerArgv);
    proto->Set(v8::String::NewSymbol("hasAutocorrectedMarker"), v8::FunctionTemplate::New(InternalsV8Internal::hasAutocorrectedMarkerCallback, v8Undefined(), hasAutocorrectedMarkerSignature));

    // Custom Signature 'numberOfScrollableAreas'
    const int numberOfScrollableAreasArgc = 1;
    v8::Handle<v8::FunctionTemplate> numberOfScrollableAreasArgv[numberOfScrollableAreasArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> numberOfScrollableAreasSignature = v8::Signature::New(desc, numberOfScrollableAreasArgc, numberOfScrollableAreasArgv);
    proto->Set(v8::String::NewSymbol("numberOfScrollableAreas"), v8::FunctionTemplate::New(InternalsV8Internal::numberOfScrollableAreasCallback, v8Undefined(), numberOfScrollableAreasSignature));

    // Custom Signature 'isPageBoxVisible'
    const int isPageBoxVisibleArgc = 2;
    v8::Handle<v8::FunctionTemplate> isPageBoxVisibleArgv[isPageBoxVisibleArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> isPageBoxVisibleSignature = v8::Signature::New(desc, isPageBoxVisibleArgc, isPageBoxVisibleArgv);
    proto->Set(v8::String::NewSymbol("isPageBoxVisible"), v8::FunctionTemplate::New(InternalsV8Internal::isPageBoxVisibleCallback, v8Undefined(), isPageBoxVisibleSignature));

    // Custom Signature 'suspendAnimations'
    const int suspendAnimationsArgc = 1;
    v8::Handle<v8::FunctionTemplate> suspendAnimationsArgv[suspendAnimationsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> suspendAnimationsSignature = v8::Signature::New(desc, suspendAnimationsArgc, suspendAnimationsArgv);
    proto->Set(v8::String::NewSymbol("suspendAnimations"), v8::FunctionTemplate::New(InternalsV8Internal::suspendAnimationsCallback, v8Undefined(), suspendAnimationsSignature));

    // Custom Signature 'resumeAnimations'
    const int resumeAnimationsArgc = 1;
    v8::Handle<v8::FunctionTemplate> resumeAnimationsArgv[resumeAnimationsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> resumeAnimationsSignature = v8::Signature::New(desc, resumeAnimationsArgc, resumeAnimationsArgv);
    proto->Set(v8::String::NewSymbol("resumeAnimations"), v8::FunctionTemplate::New(InternalsV8Internal::resumeAnimationsCallback, v8Undefined(), resumeAnimationsSignature));

    // Custom Signature 'scrollingStateTreeAsText'
    const int scrollingStateTreeAsTextArgc = 1;
    v8::Handle<v8::FunctionTemplate> scrollingStateTreeAsTextArgv[scrollingStateTreeAsTextArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> scrollingStateTreeAsTextSignature = v8::Signature::New(desc, scrollingStateTreeAsTextArgc, scrollingStateTreeAsTextArgv);
    proto->Set(v8::String::NewSymbol("scrollingStateTreeAsText"), v8::FunctionTemplate::New(InternalsV8Internal::scrollingStateTreeAsTextCallback, v8Undefined(), scrollingStateTreeAsTextSignature));

    // Custom Signature 'mainThreadScrollingReasons'
    const int mainThreadScrollingReasonsArgc = 1;
    v8::Handle<v8::FunctionTemplate> mainThreadScrollingReasonsArgv[mainThreadScrollingReasonsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> mainThreadScrollingReasonsSignature = v8::Signature::New(desc, mainThreadScrollingReasonsArgc, mainThreadScrollingReasonsArgv);
    proto->Set(v8::String::NewSymbol("mainThreadScrollingReasons"), v8::FunctionTemplate::New(InternalsV8Internal::mainThreadScrollingReasonsCallback, v8Undefined(), mainThreadScrollingReasonsSignature));

    // Custom Signature 'repaintRectsAsText'
    const int repaintRectsAsTextArgc = 1;
    v8::Handle<v8::FunctionTemplate> repaintRectsAsTextArgv[repaintRectsAsTextArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> repaintRectsAsTextSignature = v8::Signature::New(desc, repaintRectsAsTextArgc, repaintRectsAsTextArgv);
    proto->Set(v8::String::NewSymbol("repaintRectsAsText"), v8::FunctionTemplate::New(InternalsV8Internal::repaintRectsAsTextCallback, v8Undefined(), repaintRectsAsTextSignature));

    // Custom Signature 'garbageCollectDocumentResources'
    const int garbageCollectDocumentResourcesArgc = 1;
    v8::Handle<v8::FunctionTemplate> garbageCollectDocumentResourcesArgv[garbageCollectDocumentResourcesArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> garbageCollectDocumentResourcesSignature = v8::Signature::New(desc, garbageCollectDocumentResourcesArgc, garbageCollectDocumentResourcesArgv);
    proto->Set(v8::String::NewSymbol("garbageCollectDocumentResources"), v8::FunctionTemplate::New(InternalsV8Internal::garbageCollectDocumentResourcesCallback, v8Undefined(), garbageCollectDocumentResourcesSignature));

    // Custom Signature 'insertAuthorCSS'
    const int insertAuthorCSSArgc = 2;
    v8::Handle<v8::FunctionTemplate> insertAuthorCSSArgv[insertAuthorCSSArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> insertAuthorCSSSignature = v8::Signature::New(desc, insertAuthorCSSArgc, insertAuthorCSSArgv);
    proto->Set(v8::String::NewSymbol("insertAuthorCSS"), v8::FunctionTemplate::New(InternalsV8Internal::insertAuthorCSSCallback, v8Undefined(), insertAuthorCSSSignature));

    // Custom Signature 'insertUserCSS'
    const int insertUserCSSArgc = 2;
    v8::Handle<v8::FunctionTemplate> insertUserCSSArgv[insertUserCSSArgc] = { V8Document::GetRawTemplate(), v8::Handle<v8::FunctionTemplate>() };
    v8::Handle<v8::Signature> insertUserCSSSignature = v8::Signature::New(desc, insertUserCSSArgc, insertUserCSSArgv);
    proto->Set(v8::String::NewSymbol("insertUserCSS"), v8::FunctionTemplate::New(InternalsV8Internal::insertUserCSSCallback, v8Undefined(), insertUserCSSSignature));

    // Custom Signature 'consoleMessageArgumentCounts'
    const int consoleMessageArgumentCountsArgc = 1;
    v8::Handle<v8::FunctionTemplate> consoleMessageArgumentCountsArgv[consoleMessageArgumentCountsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> consoleMessageArgumentCountsSignature = v8::Signature::New(desc, consoleMessageArgumentCountsArgc, consoleMessageArgumentCountsArgv);
#if ENABLE(INSPECTOR)
    proto->Set(v8::String::NewSymbol("consoleMessageArgumentCounts"), v8::FunctionTemplate::New(InternalsV8Internal::consoleMessageArgumentCountsCallback, v8Undefined(), consoleMessageArgumentCountsSignature));
#endif // ENABLE(INSPECTOR)

    // Custom Signature 'counterValue'
    const int counterValueArgc = 1;
    v8::Handle<v8::FunctionTemplate> counterValueArgv[counterValueArgc] = { V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> counterValueSignature = v8::Signature::New(desc, counterValueArgc, counterValueArgv);
    proto->Set(v8::String::NewSymbol("counterValue"), v8::FunctionTemplate::New(InternalsV8Internal::counterValueCallback, v8Undefined(), counterValueSignature));

    // Custom Signature 'iconURLs'
    const int iconURLsArgc = 1;
    v8::Handle<v8::FunctionTemplate> iconURLsArgv[iconURLsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> iconURLsSignature = v8::Signature::New(desc, iconURLsArgc, iconURLsArgv);
    proto->Set(v8::String::NewSymbol("iconURLs"), v8::FunctionTemplate::New(InternalsV8Internal::iconURLsCallback, v8Undefined(), iconURLsSignature));

    // Custom Signature 'webkitWillEnterFullScreenForElement'
    const int webkitWillEnterFullScreenForElementArgc = 2;
    v8::Handle<v8::FunctionTemplate> webkitWillEnterFullScreenForElementArgv[webkitWillEnterFullScreenForElementArgc] = { V8Document::GetRawTemplate(), V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> webkitWillEnterFullScreenForElementSignature = v8::Signature::New(desc, webkitWillEnterFullScreenForElementArgc, webkitWillEnterFullScreenForElementArgv);
    proto->Set(v8::String::NewSymbol("webkitWillEnterFullScreenForElement"), v8::FunctionTemplate::New(InternalsV8Internal::webkitWillEnterFullScreenForElementCallback, v8Undefined(), webkitWillEnterFullScreenForElementSignature));

    // Custom Signature 'webkitDidEnterFullScreenForElement'
    const int webkitDidEnterFullScreenForElementArgc = 2;
    v8::Handle<v8::FunctionTemplate> webkitDidEnterFullScreenForElementArgv[webkitDidEnterFullScreenForElementArgc] = { V8Document::GetRawTemplate(), V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> webkitDidEnterFullScreenForElementSignature = v8::Signature::New(desc, webkitDidEnterFullScreenForElementArgc, webkitDidEnterFullScreenForElementArgv);
    proto->Set(v8::String::NewSymbol("webkitDidEnterFullScreenForElement"), v8::FunctionTemplate::New(InternalsV8Internal::webkitDidEnterFullScreenForElementCallback, v8Undefined(), webkitDidEnterFullScreenForElementSignature));

    // Custom Signature 'webkitWillExitFullScreenForElement'
    const int webkitWillExitFullScreenForElementArgc = 2;
    v8::Handle<v8::FunctionTemplate> webkitWillExitFullScreenForElementArgv[webkitWillExitFullScreenForElementArgc] = { V8Document::GetRawTemplate(), V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> webkitWillExitFullScreenForElementSignature = v8::Signature::New(desc, webkitWillExitFullScreenForElementArgc, webkitWillExitFullScreenForElementArgv);
    proto->Set(v8::String::NewSymbol("webkitWillExitFullScreenForElement"), v8::FunctionTemplate::New(InternalsV8Internal::webkitWillExitFullScreenForElementCallback, v8Undefined(), webkitWillExitFullScreenForElementSignature));

    // Custom Signature 'webkitDidExitFullScreenForElement'
    const int webkitDidExitFullScreenForElementArgc = 2;
    v8::Handle<v8::FunctionTemplate> webkitDidExitFullScreenForElementArgv[webkitDidExitFullScreenForElementArgc] = { V8Document::GetRawTemplate(), V8Element::GetRawTemplate() };
    v8::Handle<v8::Signature> webkitDidExitFullScreenForElementSignature = v8::Signature::New(desc, webkitDidExitFullScreenForElementArgc, webkitDidExitFullScreenForElementArgv);
    proto->Set(v8::String::NewSymbol("webkitDidExitFullScreenForElement"), v8::FunctionTemplate::New(InternalsV8Internal::webkitDidExitFullScreenForElementCallback, v8Undefined(), webkitDidExitFullScreenForElementSignature));

    // Custom Signature 'startTrackingRepaints'
    const int startTrackingRepaintsArgc = 1;
    v8::Handle<v8::FunctionTemplate> startTrackingRepaintsArgv[startTrackingRepaintsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> startTrackingRepaintsSignature = v8::Signature::New(desc, startTrackingRepaintsArgc, startTrackingRepaintsArgv);
    proto->Set(v8::String::NewSymbol("startTrackingRepaints"), v8::FunctionTemplate::New(InternalsV8Internal::startTrackingRepaintsCallback, v8Undefined(), startTrackingRepaintsSignature));

    // Custom Signature 'stopTrackingRepaints'
    const int stopTrackingRepaintsArgc = 1;
    v8::Handle<v8::FunctionTemplate> stopTrackingRepaintsArgv[stopTrackingRepaintsArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> stopTrackingRepaintsSignature = v8::Signature::New(desc, stopTrackingRepaintsArgc, stopTrackingRepaintsArgv);
    proto->Set(v8::String::NewSymbol("stopTrackingRepaints"), v8::FunctionTemplate::New(InternalsV8Internal::stopTrackingRepaintsCallback, v8Undefined(), stopTrackingRepaintsSignature));

    // Custom Signature 'getCurrentCursorInfo'
    const int getCurrentCursorInfoArgc = 1;
    v8::Handle<v8::FunctionTemplate> getCurrentCursorInfoArgv[getCurrentCursorInfoArgc] = { V8Document::GetRawTemplate() };
    v8::Handle<v8::Signature> getCurrentCursorInfoSignature = v8::Signature::New(desc, getCurrentCursorInfoArgc, getCurrentCursorInfoArgv);
    proto->Set(v8::String::NewSymbol("getCurrentCursorInfo"), v8::FunctionTemplate::New(InternalsV8Internal::getCurrentCursorInfoCallback, v8Undefined(), getCurrentCursorInfoSignature));

    // Custom Signature 'deserializeBuffer'
    const int deserializeBufferArgc = 1;
    v8::Handle<v8::FunctionTemplate> deserializeBufferArgv[deserializeBufferArgc] = { V8ArrayBuffer::GetRawTemplate() };
    v8::Handle<v8::Signature> deserializeBufferSignature = v8::Signature::New(desc, deserializeBufferArgc, deserializeBufferArgv);
    proto->Set(v8::String::NewSymbol("deserializeBuffer"), v8::FunctionTemplate::New(InternalsV8Internal::deserializeBufferCallback, v8Undefined(), deserializeBufferSignature));
    V8DOMConfiguration::batchConfigureConstants(desc, proto, V8InternalsConsts, WTF_ARRAY_LENGTH(V8InternalsConsts));

    // Custom toString template
    desc->Set(v8::String::NewSymbol("toString"), V8PerIsolateData::current()->toStringTemplate());
    return desc;
}

v8::Persistent<v8::FunctionTemplate> V8Internals::GetRawTemplate()
{
    V8PerIsolateData* data = V8PerIsolateData::current();
    V8PerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->value;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Persistent<v8::FunctionTemplate> V8Internals::GetTemplate()
{
    V8PerIsolateData* data = V8PerIsolateData::current();
    V8PerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->value;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8InternalsTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

bool V8Internals::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}


v8::Handle<v8::Object> V8Internals::createWrapper(PassRefPtr<Internals> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)
{
    ASSERT(impl.get());
    ASSERT(DOMDataStore::getWrapper(impl.get(), isolate).IsEmpty());

    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &info, impl.get());
    if (UNLIKELY(wrapper.IsEmpty()))
        return wrapper;

    installPerContextProperties(wrapper, impl.get());
    v8::Persistent<v8::Object> wrapperHandle = V8DOMWrapper::associateObjectWithWrapper(impl, &info, wrapper, isolate);
    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    return wrapper;
}

void V8Internals::derefObject(void* object)
{
    static_cast<Internals*>(object)->deref();
}

} // namespace WebCore
